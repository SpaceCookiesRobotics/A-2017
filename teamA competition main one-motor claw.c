#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  leftGrabber,    sensorNone)
#pragma config(Sensor, I2C_2,  rightGrabber,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           frontLeft,     tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           bottomLeft,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           bottomRight,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           grabber,       tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port5,           backLeft,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           frontRight,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           topLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           topRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          backRight,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "../Shared/Competition.h"

int speedDriver = 1; // divider for slow speed on chassis
int speedGrabber = 1;
// continuously monitor the slow speed button
// when the slow speed button is pressed, change the speed dividor speedDriver
// normal speeds are divided by this value
task chassisSlow(){
	while(true){
		// if main driver presses button 5 Up, go at half speed
		if (vexRT[Btn5U]==1){
			speedDriver = 2;
			// chassis speed to half
		}
		else{
			speedDriver = 1;
			//otherwise normal speed
		}
		// if partner presses button 8 up, grabber and lift go at half speed
		if (vexRT[Btn8UXmtr2]==1){
			speedGrabber = 2;
			// grabber and lift speed to half
		}
		else{
			speedGrabber = 1;
			// otherwise normal grabber and lift speed
		}
		displayLCDNumber(0,0,speedDriver);

	}//while
};

void closeGrabber(void){ motor[grabber] = 127/speedGrabber;}
void openGrabber(void){ motor[grabber] = -127/speedGrabber;}


//open grabber completely at start, to give the grabber a starting position
void homeFinger(int mot){
	//last value from the motor is equal to the encoder value
	float lastVal = nMotorEncoder[mot];
	int curVal=lastVal+1000; // something different
//	float runningAverage=lastVal;
	// still moving function is true
	bool stillMoving = true;
	// turn motor on
	motor[mot] = -20;// has to be weak enough for the gears to not skip
	// forever doing still moving function
	while (stillMoving){
		// pause for ten milliseconds to let encoder gather information
		sleep(100);
		// current motor value is the encoder value
		curVal = nMotorEncoder[mot];
		//runningAverage = 0.9*curVal + 0.1*runningAverage;
		// "still moving" is true when current value is not last value
		//stillMoving = (curVal != lastVal);
		stillMoving = abs(curVal-lastVal)>2;
		if(!stillMoving) break;

		//stillMoving = fabs(runningAverage-lastVal)< 2;
		// stop program when not moving
		lastVal=curVal;
		// exit while true loop
	}
	// turn motor off
	motor[mot] = 0;
	sleep(200);
		// make this measured position as "zero" (to base off of for next commands)
	nMotorEncoder[mot] = 0;
}

// for grabbers to grab object
// last test on 11-7 this directly followed homing function and almost desrtoyed robot; needs to be moved so that tests do not destory robot
//void snatch(void){
//	//will not give back any new values
//	int lastRightVal = nMotorEncoder[rightGrabber];
//	//last right grabber motor value is its encoder value
//	int lastLeftVal = nMotorEncoder[leftGrabber];
//	//last left grabber motor value is its encoder value
//	bool stillMoving = true;
//	// turn motor on
//	closeLeft();//motor[leftGrabber] = -127/speedGrabber;
//	//to bring left grabber to cone to grab it
//	closeRight(); //motor[rightGrabber] = -127/speedGrabber;
//	//to bring right grabber to cone to grab it
//	while (stillMoving){
//		// pause for ten milliseconds to let encoder gather information
//		sleep(100);
//		// current left grabber motor value is the new encoder value
//		int curLeftVal = nMotorEncoder[leftGrabber];
//		// current right grabber motor value is the new encoder value
//		int curRightVal = nMotorEncoder[rightGrabber];
//		//"still moving" occurs when:
//		//current left grabber motor value has changed since last check
//		//and current right grabber motor value has changed since last check
//		stillMoving = (curLeftVal != lastLeftVal) && (curRightVal != lastRightVal);
//		//left grabber motor value does not change
//		lastLeftVal=curLeftVal;
//		//right grabber motor value does not change
//		lastRightVal=curRightVal;
//		//function goal acheived, so exit while true loop
//	}
//	// make this measured position as "zero" (to grip stronger on cone)
//	motor[grabber] = -20;
//}

//this function will not send back new numbers
void joystick(){

	startTask (chassisSlow); // monitor slow speed buttons
	//continue forever
	while(true){
		displayLCDNumber(1,0,speedDriver);
		//chassis motors
		motor[frontLeft] = vexRT[Ch3]/speedDriver;
		motor[backLeft] = vexRT[Ch3]/speedDriver;
		motor[frontRight] = vexRT[Ch2]/speedDriver;
		motor[backRight] = vexRT[Ch2]/speedDriver;
		//lift motors
		motor[bottomLeft] = vexRT[Ch2Xmtr2]/speedGrabber;
		motor[bottomRight] = vexRT[Ch2Xmtr2]/speedGrabber;
		motor[topLeft] = vexRT[Ch2Xmtr2]/speedGrabber;
		motor[topRight] = vexRT[Ch2Xmtr2]/speedGrabber;
		//grabber motors
		// up button=close, down button = open
		// button for right grabber to close on cone
		//if pressed, right grabber closes
		if (vexRT[Btn6UXmtr2] && !vexRT[Btn6DXmtr2]) {
			closeGrabber();
		};
		//button for right grabber to open
		//if pressed, right grabber opens
		if (vexRT[Btn6DXmtr2] && !vexRT[Btn6UXmtr2]) {
			openGrabber();
		};
		//if neither button is pressed, right grabber does nothing
		if (!(vexRT[Btn6UXmtr2] || vexRT[Btn6DXmtr2])) {
			motor[grabber] = 0;
		};

	}//exit while loop
}//end taskMain

void autonomous() {

}
